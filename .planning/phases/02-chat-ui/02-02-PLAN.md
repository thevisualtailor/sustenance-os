---
phase: 02-chat-ui
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/chat/message-renderer.js
  - src/chat/scroll-anchor.js
  - src/chat/chat-view.js
  - src/chat/chat-view.css
  - package.json
autonomous: false

must_haves:
  truths:
    - "AI responses render markdown correctly — bold text, bullet lists, and headers are visually distinct"
    - "User can scroll up to read earlier messages without being yanked back down"
    - "When scrolled up and a new message arrives, a 'New message' chip appears — tapping it scrolls to bottom"
    - "Timestamps appear on AI messages only (not user messages)"
    - "Dark theme, palette, and typography match Compound OS visually"
    - "Chat feels polished on iPhone — keyboard pushes input up, no layout jumps"
  artifacts:
    - path: "src/chat/message-renderer.js"
      provides: "Markdown-safe message rendering"
      exports: ["renderMessage"]
    - path: "src/chat/scroll-anchor.js"
      provides: "Scroll anchoring with new-message chip"
      exports: ["createScrollAnchor"]
  key_links:
    - from: "src/chat/message-renderer.js"
      to: "marked"
      via: "import marked, sanitize with DOMPurify"
      pattern: "DOMPurify\\.sanitize.*marked\\.parse"
    - from: "src/chat/scroll-anchor.js"
      to: "src/chat/chat-view.js"
      via: "observes message-thread scroll position"
      pattern: "scrollHeight.*scrollTop.*clientHeight"
    - from: "src/chat/chat-view.js"
      to: "src/chat/message-renderer.js"
      via: "import renderMessage, use for all message display"
      pattern: "renderMessage"
---

<objective>
Wire in markdown rendering, scroll anchoring with new-message chip, timestamps, and load-more control. Then verify the complete chat UI on iPhone.

Purpose: This plan transforms the basic chat from Plan 01 into a polished coaching-grade interface. Markdown rendering makes AI responses readable. Scroll anchoring prevents the frustrating yank-to-bottom behavior. The iPhone checkpoint confirms everything works on the real target device.

Output: A complete, polished chat UI that renders rich markdown responses, handles scroll position intelligently, and passes visual verification on iPhone.
</objective>

<execution_context>
@/Users/jaycarter/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jaycarter/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chat-ui/02-CONTEXT.md
@.planning/phases/02-chat-ui/02-RESEARCH.md
@.planning/phases/02-chat-ui/02-01-SUMMARY.md
@src/chat/chat-view.js
@src/chat/chat-view.css
@src/chat/message-store.js
@src/styles/main.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install marked + DOMPurify and create message renderer</name>
  <files>src/chat/message-renderer.js, src/chat/chat-view.js, src/chat/chat-view.css, package.json</files>
  <action>
**Install dependencies:**
```bash
npm install marked dompurify
```

**src/chat/message-renderer.js** — export `renderMessage(message)`:

Takes a message object `{ id, role, content, timestamp }` and returns a DOM element.

1. Import `marked` and `DOMPurify`:
   ```js
   import { marked } from 'marked';
   import DOMPurify from 'dompurify';
   ```

2. For `role === 'assistant'`:
   - Create `.message.message--assistant` div
   - Create `.message__content` div inside it
   - Set innerHTML to `DOMPurify.sanitize(marked.parse(content))` — this is the ONLY place innerHTML is used with user-facing content, and it is sanitized
   - Create `.message__timestamp` span with formatted time (HH:MM 24hr format): `new Date(timestamp).toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' })`
   - Append timestamp after content

3. For `role === 'user'`:
   - Create `.message.message--user` div
   - Create `.message__content` div inside it
   - Set `textContent = content` (no markdown, no innerHTML — user messages are plain text, XSS-safe)
   - NO timestamp on user messages (per locked decision)

4. Return the constructed DOM element

**Update chat-view.js:**
- Import `renderMessage` from `./message-renderer.js`
- Replace the basic message div creation (from Plan 01) with `renderMessage(msg)` calls
- When a new message is added to the store, call `renderMessage(msg)` and append the returned element to `.message-thread`

**Add message rendering CSS to chat-view.css:**

AI message content markdown styles (scoped under `.message--assistant .message__content`):
```css
.message--assistant .message__content h1,
.message--assistant .message__content h2,
.message--assistant .message__content h3 {
  font-family: var(--font-heading);
  font-weight: 600;
  margin: 12px 0 6px;
  color: var(--text-primary);
}
.message--assistant .message__content h2 { font-size: 16px; }
.message--assistant .message__content h3 { font-size: 15px; }
.message--assistant .message__content p { margin: 6px 0; }
.message--assistant .message__content ul,
.message--assistant .message__content ol {
  padding-left: 20px;
  margin: 6px 0;
}
.message--assistant .message__content li { margin: 3px 0; }
.message--assistant .message__content strong { color: var(--text-primary); font-weight: 600; }
.message--assistant .message__content code {
  background: var(--bg-surface);
  padding: 2px 5px;
  border-radius: 4px;
  font-family: var(--font-body);
  font-size: 13px;
}
```

Timestamp styles:
```css
.message__timestamp {
  display: block;
  font-size: 11px;
  color: var(--text-muted);
  margin-top: 6px;
  font-family: var(--font-body);
}
```
  </action>
  <verify>`npm ls marked dompurify` shows both packages installed. `npm run build` succeeds with exit code 0.</verify>
  <done>
AI responses render markdown (bold, lists, headers) correctly via marked + DOMPurify. User messages render as plain text. Timestamps appear on AI messages only. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add scroll anchoring, new-message chip, and load-more control</name>
  <files>src/chat/scroll-anchor.js, src/chat/chat-view.js, src/chat/chat-view.css</files>
  <action>
**src/chat/scroll-anchor.js** — export `createScrollAnchor(threadEl)`:

Returns an object with:
- `onNewMessage()`: called after a new message is appended to the DOM
  - If user is at bottom (within 50px threshold): smooth-scroll to bottom
  - If user is scrolled up: show the "New message" chip instead of scrolling
- `destroy()`: removes event listeners

Implementation:
```js
export function createScrollAnchor(threadEl) {
  let chipEl = null;

  function isAtBottom() {
    return threadEl.scrollHeight - threadEl.scrollTop - threadEl.clientHeight < 50;
  }

  function scrollToBottom() {
    threadEl.scrollTo({ top: threadEl.scrollHeight, behavior: 'smooth' });
  }

  function showChip() {
    if (chipEl) return; // already showing
    chipEl = document.createElement('button');
    chipEl.className = 'new-message-chip';
    chipEl.textContent = 'New message';
    chipEl.addEventListener('click', () => {
      scrollToBottom();
      hideChip();
    });
    threadEl.parentElement.appendChild(chipEl); // append to .chat-view, not thread
  }

  function hideChip() {
    if (chipEl) {
      chipEl.remove();
      chipEl = null;
    }
  }

  function onScroll() {
    if (isAtBottom()) hideChip();
  }

  threadEl.addEventListener('scroll', onScroll);

  return {
    onNewMessage() {
      if (isAtBottom()) {
        // Use requestAnimationFrame to ensure DOM has updated
        requestAnimationFrame(() => scrollToBottom());
      } else {
        showChip();
      }
    },
    destroy() {
      threadEl.removeEventListener('scroll', onScroll);
      hideChip();
    }
  };
}
```

**Add load-more control to chat-view.js:**
- When rendering messages, only render the last N (50) from the store
- If `store.hasMore(50)` is true, prepend a "Load earlier messages" button at the top of the message thread
- When clicked, load the next batch of older messages, prepend them to the DOM
- Preserve scroll position when prepending (save scrollHeight before, restore scrollTop after):
  ```js
  const prevScrollHeight = threadEl.scrollHeight;
  // ...prepend messages...
  threadEl.scrollTop = threadEl.scrollTop + (threadEl.scrollHeight - prevScrollHeight);
  ```

**Wire scroll anchoring into chat-view.js:**
- Import `createScrollAnchor` and instantiate with the `.message-thread` element
- After each message is appended to the DOM (both user and assistant), call `scrollAnchor.onNewMessage()`
- On initial load (first message sent), scroll to bottom automatically

**New message chip CSS:**
```css
.new-message-chip {
  position: absolute;
  bottom: 80px; /* above input bar */
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-family: var(--font-body);
  font-size: 13px;
  cursor: pointer;
  z-index: 10;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  min-height: 36px;
  min-width: auto;
}
```

**Load more button CSS:**
```css
.load-more-btn {
  display: block;
  margin: 8px auto 16px;
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  border-radius: 8px;
  padding: 6px 14px;
  font-family: var(--font-body);
  font-size: 12px;
  cursor: pointer;
  min-height: 32px;
  min-width: auto;
}
```

**Ensure `.chat-view` has `position: relative`** so the absolute-positioned chip is contained within it. (This should already be set from Plan 01 Task 1, but verify and add if missing.)

**Push to GitHub after all changes are complete** — Vercel will auto-deploy for the iPhone verification checkpoint.
  </action>
  <verify>`npm run build` succeeds with exit code 0. `git push` completes and Vercel deployment triggers.</verify>
  <done>
Scroll anchoring works: auto-scrolls when at bottom, shows "New message" chip when scrolled up. Chip is tappable to jump to bottom. Load-more control exists for message cap at 50. Deployed to Vercel for iPhone testing.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete chat UI on iPhone</name>
  <what-built>
Complete chat interface with:
- Flex column layout (message thread + input bar)
- Auto-expanding textarea (1-4 lines, Enter=newline, button=send)
- Empty state branding ("SustenanceOS" / "Persistent Imperfection") with fade transition
- User messages right-aligned, AI messages full-width with markdown rendering
- Timestamps on AI messages only
- "Thinking..." pulsing animation during response delay
- Scroll anchoring with "New message" chip
- Compound OS dark theme throughout
  </what-built>
  <how-to-verify>
Visit https://sustenance-os.vercel.app on iPhone (or add to home screen and open from there):

1. **Empty state:** On load, "SustenanceOS" and "Persistent Imperfection" should be centered in the middle of the screen
2. **Send a message:** Type "Hello" and tap the Send button. Verify:
   - User message appears right-aligned in a subtle bubble
   - "Thinking..." appears with animated pulsing dots
   - After ~1.5s, AI response appears full-width with markdown formatting (bold, bullets, header)
   - Empty state branding fades out smoothly (opacity transition)
   - AI message has a timestamp (HH:MM), user message does not
3. **Typography:** Roboto Mono for message body text, Roboto Mono for timestamps. Instrument Serif for empty state title only.
4. **Keyboard behavior:** Tap the textarea — keyboard should push the input bar up (not cover it). Type multiple lines — textarea should grow. Press Enter — should add a newline, NOT send.
5. **Scroll behavior:** Send several messages to fill the screen. Scroll up. Send another message (you may need to scroll down to reach the input). A "New message" chip should appear. Tap it to jump to bottom.
6. **Visual polish:** Dark theme, clean typography, no horizontal scroll, no layout jumps when keyboard opens/closes. Chat fills full viewport width (no clipping from parent padding).
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. All four CHAT requirements are met:
   - CHAT-01: Chat UI with message bubbles and thread layout
   - CHAT-02: Compound OS dark theme (palette, typography, spacing)
   - CHAT-03: Markdown rendering in AI responses (bold, lists, headers)
   - CHAT-04: Session history (scroll up for earlier messages, in-memory store)
3. Locked decisions verified:
   - AI messages full-width, user messages right-aligned bubbles
   - No avatars on any messages
   - Timestamps on AI messages only
   - Enter=newline, Send=button only
   - Send button never disabled
   - Empty state with correct fonts and tagline, fades out
   - Auto-scroll only when at bottom, chip when not
4. Live on Vercel, verified on iPhone
</verification>

<success_criteria>
- AI responses render markdown (bold, bullets, headers) via marked + DOMPurify
- User messages are plain text, right-aligned
- Timestamps appear on AI messages only (HH:MM format)
- Scroll anchoring: auto-scroll at bottom, "New message" chip when scrolled up
- Chat feels polished on iPhone — keyboard behavior, no layout jumps
- All CHAT-01 through CHAT-04 requirements demonstrably met
- Human verification approved on real iPhone
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-ui/02-02-SUMMARY.md`
</output>
