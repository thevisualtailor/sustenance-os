---
phase: 02-chat-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/chat/chat-view.js
  - src/chat/chat-view.css
  - src/chat/message-store.js
  - src/main.js
  - index.html
autonomous: true

must_haves:
  truths:
    - "Chat view fills the screen with a message thread area and input bar at the bottom"
    - "User can type a message in an auto-expanding textarea and tap Send to submit"
    - "Empty state shows 'SustenanceOS' in Instrument Serif and 'Persistent Imperfection' in Roboto Mono, centered"
    - "Empty state fades out with opacity transition when messages appear"
    - "Sending a message adds it to the in-memory store and displays a stub AI response after a thinking delay"
    - "Enter key adds a newline — it does NOT send the message"
  artifacts:
    - path: "src/chat/chat-view.js"
      provides: "Chat view factory function"
      exports: ["createChatView"]
    - path: "src/chat/chat-view.css"
      provides: "Chat layout styles (flex column, input bar, thread, empty state)"
      min_lines: 60
    - path: "src/chat/message-store.js"
      provides: "In-memory message store with stub AI response"
      exports: ["createMessageStore"]
  key_links:
    - from: "src/main.js"
      to: "src/chat/chat-view.js"
      via: "import and mount to main element"
      pattern: "createChatView"
    - from: "src/chat/chat-view.js"
      to: "src/chat/message-store.js"
      via: "import store, call addMessage and getStubResponse"
      pattern: "createMessageStore"
    - from: "src/chat/chat-view.js"
      to: "src/chat/chat-view.css"
      via: "CSS import for styles"
      pattern: "import.*chat-view\\.css"
---

<objective>
Build the core chat view — flex column layout, auto-expanding input field, message thread container, empty state branding with fade transition, and in-memory message store with stub AI responses.

Purpose: This is the foundation for the entire chat UI. Without the layout, input mechanism, and message store, nothing else in Phase 2 can function. The stub response lets us test the full send/receive loop without an AI backend.

Output: A working chat view that replaces the placeholder, where the user can type messages and see stub responses appear in a scrollable thread.
</objective>

<execution_context>
@/Users/jaycarter/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jaycarter/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chat-ui/02-CONTEXT.md
@.planning/phases/02-chat-ui/02-RESEARCH.md
@src/main.js
@src/view/app-shell.js
@src/styles/main.css
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat view layout with input bar and empty state</name>
  <files>src/chat/chat-view.js, src/chat/chat-view.css, src/main.js, index.html</files>
  <action>
Create the chat view module following the established app shell pattern (feature modules in src/{feature}/, factory function pattern).

**src/chat/chat-view.js** — export `createChatView(container)`:

IMPORTANT: Add `import './chat-view.css';` at the top of the file so Vite bundles the styles. Without this import the stylesheet will be unreferenced at runtime.

1. Create a `.chat-view` wrapper div that holds the entire chat interface
2. Inside it, create `.message-thread` div (scrollable message area) and `.chat-input` div (input bar)
3. The `.chat-input` contains:
   - A `<textarea>` that auto-expands from 1 line to max 4 lines (~96px at 24px line-height), then becomes scrollable. CRITICAL: use `box-sizing: border-box` to prevent infinite growth. Use the JS scrollHeight pattern from research:
     ```js
     textarea.addEventListener('input', () => {
       textarea.style.height = 'auto';
       textarea.style.height = Math.min(textarea.scrollHeight, 96) + 'px';
       textarea.style.overflowY = textarea.scrollHeight > 96 ? 'scroll' : 'hidden';
     });
     ```
   - A send button (icon or "Send" text — keep minimal)
   - Enter key MUST add a newline (default behavior). Do NOT intercept Enter to send. Send is button-tap only per locked decision.
   - Send button stays active/enabled at all times — never disable it, even while "AI is responding"
4. Empty state: Create a `.chat-empty` div centered in the message thread area containing:
   - "SustenanceOS" in Instrument Serif (font-size: 22px, font-weight: 400 — Google Fonts only ships 400, opacity: 0.65 for medium visual weight)
   - "Persistent Imperfection" in Roboto Mono beneath it (font-size: 13px, opacity: 0.4)
   - Both elements are wrapped in `.chat-empty` which has a CSS `transition: opacity 0.4s ease` so they FADE out (per user decision that elements "fade" away)
   - When messages exist, add class `.chat-empty--hidden` which sets `opacity: 0; pointer-events: none;` — the transition handles the fade
5. Append the `.chat-view` to the provided container

**src/chat/chat-view.css** — all chat layout styles:
- `.chat-view`: `height: calc(100dvh - var(--header-height, 60px)); display: flex; flex-direction: column; position: relative;`  — DO NOT use `position: fixed` (broken on iOS Safari per research)
- `.message-thread`: `flex: 1; overflow-y: auto; padding: 16px;`
- `.chat-input`: `flex-shrink: 0; padding: 12px 16px; border-top: 1px solid var(--border); display: flex; align-items: flex-end; gap: 8px;`
- `.chat-input textarea`: `flex: 1; resize: none; overflow-y: hidden; min-height: 44px; max-height: 96px; background: var(--bg-surface); color: var(--text-primary); border: 1px solid var(--border); border-radius: 12px; padding: 10px 14px; font-family: var(--font-body); font-size: 15px; line-height: 1.5;`
- `.chat-input button`: Send button styled with `--accent` color, 44px min tap target
- `.chat-empty`: centered in thread area using flex, vertically and horizontally. Add `transition: opacity 0.4s ease;` for the fade effect
- `.chat-empty--hidden`: `opacity: 0; pointer-events: none;` (the transition on `.chat-empty` makes this a smooth fade)
- Use existing CSS custom properties from main.css (--bg, --bg-surface, --text-primary, --border, --accent, --font-body)
- Add `--header-height: 52px;` to `:root` in main.css (measure from existing .app-header styles)
- **Override parent container constraints for full-bleed chat:** Add rules to remove `#app` padding and `.app-main` max-width when the chat view is present:
  ```css
  #app:has(.chat-view) { padding: 0; }
  .app-main:has(.chat-view) { max-width: none; padding: 0; }
  ```
  This ensures the chat fills the full viewport width on iPhone without being clipped by the app shell's default padding/max-width. (If `:has()` is not supported in target browsers, use a JS-applied class on `#app` as fallback — but `:has()` has broad support including iOS Safari 15.4+.)

**src/main.js** — COMPLETE REPLACEMENT (not an addition):
This file's content is being fully replaced, not appended to. Remove ALL existing placeholder code (the placeholder div creation, any "Hello SustenanceOS" content). The new content should be:
- Import `createAppShell` from `./view/app-shell.js`
- Import `createChatView` from `./chat/chat-view.js`
- Get the `#app` element
- Call `const { main } = createAppShell(app)`
- Call `createChatView(main)`

**index.html** — add viewport meta for mobile keyboard handling:
- Update the viewport meta to: `width=device-width, initial-scale=1.0, interactive-widget=resizes-content`
- This helps Chrome/Firefox resize layout when keyboard opens. iOS Safari degrades gracefully using dvh.
  </action>
  <verify>`npm run build` succeeds with exit code 0. Verify chat-view.js contains `import './chat-view.css'` and main.js imports createChatView (not placeholder code).</verify>
  <done>
Chat layout renders correctly with flex column (thread + input bar), auto-expanding textarea works with Enter=newline, empty state branding is visible and centered with opacity fade transition on `.chat-empty`, parent container padding/max-width overridden for full-bleed layout, main.js fully replaced with chat view mount, build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create message store with stub AI response</name>
  <files>src/chat/message-store.js, src/chat/chat-view.js</files>
  <action>
**src/chat/message-store.js** — export `createMessageStore()`:

Returns an object with:
- `messages`: internal array of message objects `{ id, role, content, timestamp }`
  - `role`: `'user'` or `'assistant'`
  - `content`: string (plain text for user, markdown for assistant)
  - `timestamp`: `Date.now()`
  - `id`: simple incrementing counter or `crypto.randomUUID()`
- `addMessage(role, content)`: pushes a new message, returns the message object
- `getMessages()`: returns full array
- `getVisible(n)`: returns last N messages (default N=50 per research recommendation — Claude's discretion area)
- `hasMore(n)`: returns true if total messages > n (for load more control)
- `getOlder(n, offset)`: returns messages before the visible window for load-more

**Stub AI response function** — export `getStubResponse()`:

Returns a promise that resolves after 1.5 seconds with a markdown-rich string that exercises bold, bullets, and a header. Example:

```
"## Great question!\n\nHere are a few things to consider:\n\n- **Consistency** matters more than perfection\n- Try to include a source of protein with each meal\n- Your fire meals list has some solid options for this\n\nWhat meal are you thinking about?"
```

This stub exists purely for Phase 2 testing — it will be replaced by real AI calls in Phase 3. Include a comment noting this.

**Wire into chat-view.js:**

Update `createChatView` to:
1. Import and instantiate `createMessageStore()`
2. On send button click (or form submit):
   a. Read textarea value, trim it. If empty, do nothing.
   b. Call `store.addMessage('user', text)` — render the user message in the thread (simple text div for now — Plan 02 handles full rendering)
   c. Clear textarea, reset its height to initial
   d. Show a "Thinking..." indicator in the thread (a temporary div with class `.thinking-indicator` containing `Thinking<span>.</span><span>.</span><span>.</span>`)
   e. Call `getStubResponse()`, await it
   f. Remove thinking indicator
   g. Call `store.addMessage('assistant', response)` — render the AI response (innerHTML of raw text for now — Plan 02 adds markdown parsing)
   h. Hide the empty state by adding `.chat-empty--hidden` class (this triggers the opacity fade transition from Task 1)
3. For this plan, message rendering is BASIC — just create divs with textContent for user, innerHTML for assistant. Plan 02 will replace this with proper message-renderer.js.
4. User messages: right-aligned, smaller bubble style (`.message--user`)
5. AI messages: full-width, no bubble (`.message--assistant`)

**Add thinking indicator CSS to chat-view.css:**
```css
@keyframes thinking-pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}
.thinking-indicator {
  color: var(--text-muted);
  font-family: var(--font-body);
  font-size: 14px;
  padding: 12px 0;
}
.thinking-indicator span {
  animation: thinking-pulse 1.4s ease-in-out infinite;
}
.thinking-indicator span:nth-child(2) { animation-delay: 0.2s; }
.thinking-indicator span:nth-child(3) { animation-delay: 0.4s; }
```

**Add basic message bubble CSS to chat-view.css:**
```css
.message { padding: 8px 0; }
.message--user {
  display: flex; justify-content: flex-end;
}
.message--user .message__content {
  background: var(--bg-elevated);
  border-radius: 16px 16px 4px 16px;
  padding: 10px 14px;
  max-width: 80%;
  font-size: 15px;
}
.message--assistant {
  padding: 12px 0;
  font-size: 15px;
  line-height: 1.6;
}
```
  </action>
  <verify>`npm run build` succeeds with exit code 0. Verify message-store.js exports createMessageStore and getStubResponse.</verify>
  <done>
User can type a message, tap send, see it appear right-aligned, watch the thinking animation, and receive a styled stub AI response full-width. Empty state fades out after first message via opacity transition. Messages accumulate in the in-memory store.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Chat view renders below header, fills remaining viewport height
3. Empty state visible on fresh load, fades out with opacity transition after first message
4. Send flow works: type -> tap send -> user bubble -> thinking... -> AI response
5. Textarea auto-expands and Enter adds newline (does not send)
6. No horizontal scrolling on mobile viewport (375px)
7. chat-view.js imports chat-view.css (link is not dangling)
8. main.js is a clean replacement with no leftover placeholder code
9. #app padding and .app-main max-width do not clip the chat layout
</verification>

<success_criteria>
- Chat layout renders with flex column (thread area + input bar) filling viewport below header
- Auto-expanding textarea works correctly (1 line to 4 lines max, then scrollable)
- Enter key adds newline, Send button submits message
- Empty state branding ("SustenanceOS" / "Persistent Imperfection") visible on load, fades out with opacity transition when messages exist
- User messages appear right-aligned, AI responses appear full-width
- "Thinking..." pulsing animation shows during stub response delay
- In-memory message store tracks all messages
- Parent container padding/max-width overridden for full-bleed chat
- Build passes, no console errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-ui/02-01-SUMMARY.md`
</output>
